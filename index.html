<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snake (Flask + HTML)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#111; --fg:#e7e7e7; --accent:#32cd32; --apple:#ff4d4d; }
    body {
      margin: 0; background: var(--bg); color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: grid; place-items: center; min-height: 100vh;
    }
    .wrap { text-align: center; padding: 16px; }
    h1 { margin: 0 0 8px; font-weight: 700; }
    .meta { opacity: .8; margin-bottom: 12px; }
    canvas {
      background: #000; border: 2px solid #333; border-radius: 8px;
      image-rendering: pixelated;
      touch-action: none; /* prevent touch scrolling */
    }
    .bar {
      display: flex; gap: 12px; justify-content: center; align-items: center;
      margin: 12px 0 8px;
    }
    .btn {
      background: #222; border: 1px solid #333; color: var(--fg);
      padding: 8px 12px; border-radius: 8px; cursor: pointer;
    }
    .btn:hover { background: #2b2b2b; }
    .score { padding: 6px 10px; border: 1px solid #333; border-radius: 8px; }
    .hint { opacity: .7; font-size: 13px; }
    /* Mobile arrows */
    .pad { display: grid; grid-template-columns: repeat(3, 60px); gap: 8px; justify-content: center; margin-top: 12px; }
    .pad button { width:60px; height:60px; border-radius:12px; border:1px solid #333; background:#1c1c1c; color:var(--fg); font-size:18px; }
    .pad .empty { visibility: hidden; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üêç Snake</h1>
    <div class="meta">Flask + HTML + JS</div>

    <div class="bar">
      <button class="btn" id="btnStart">Start / Restart</button>
      <button class="btn" id="btnPause">Pause</button>
      <div class="score">Score: <span id="score">0</span></div>
      <div class="score">High Score: <span id="high">0</span></div>
    </div>

    <canvas id="game" width="420" height="420"></canvas>

    <div class="hint">Use Arrow Keys or WASD. On mobile, use the arrows below.</div>

    <div class="pad" id="pad">
      <div class="empty"></div>
      <button data-dir="up">‚¨ÜÔ∏è</button>
      <div class="empty"></div>
      <button data-dir="left">‚¨ÖÔ∏è</button>
      <button data-dir="down">‚¨áÔ∏è</button>
      <button data-dir="right">‚û°Ô∏è</button>
    </div>
  </div>

  <script>
    // --- Game constants ---
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const SIZE = 20;                  // cell size (px)
    const COLS = Math.floor(canvas.width / SIZE);
    const ROWS = Math.floor(canvas.height / SIZE);
    const SPEED_MS = 150;             // lower = faster

    // --- UI elements ---
    const scoreEl = document.getElementById("score");
    const highEl  = document.getElementById("high");
    const btnStart = document.getElementById("btnStart");
    const btnPause = document.getElementById("btnPause");

    // --- Game state ---
    let snake, dir, nextDir, apple, score, timer, paused, gameOver;

    function init() {
      snake = [{x:2, y:2}, {x:1, y:2}, {x:0, y:2}];
      dir = {x:1, y:0};
      nextDir = {...dir};
      apple = spawnApple();
      score = 0;
      paused = false;
      gameOver = false;
      updateScore();
      clearInterval(timer);
      timer = setInterval(tick, SPEED_MS);
      draw();
    }

    function spawnApple() {
      while (true) {
        const a = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) };
        if (!snake.some(s => s.x === a.x && s.y === a.y)) return a;
      }
    }

    function tick() {
      if (paused || gameOver) return;
      // apply nextDir if it's not opposite
      if ((nextDir.x !== -dir.x || nextDir.y !== -dir.y) &&
          (nextDir.x !== dir.x || nextDir.y !== dir.y)) {
        dir = nextDir;
      } else {
        // allow same dir
        dir = nextDir;
      }

      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // wall collision
      if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
        return endGame();
      }
      // self collision
      if (snake.some(s => s.x === head.x && s.y === head.y)) {
        return endGame();
      }

      snake.unshift(head);

      // eat apple?
      if (head.x === apple.x && head.y === apple.y) {
        score += 10;
        updateScore();
        apple = spawnApple();
      } else {
        snake.pop();
      }

      draw();
    }

    function drawGrid() {
      ctx.strokeStyle = "#111";
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x*SIZE, 0);
        ctx.lineTo(x*SIZE, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y*SIZE);
        ctx.lineTo(canvas.width, y*SIZE);
        ctx.stroke();
      }
    }

    function draw() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      drawGrid();

      // draw apple
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--apple').trim() || "#ff4d4d";
      ctx.fillRect(apple.x*SIZE, apple.y*SIZE, SIZE, SIZE);

      // draw snake
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || "#32cd32";
      snake.forEach((s, i) => {
        ctx.fillRect(s.x*SIZE, s.y*SIZE, SIZE, SIZE);
        // simple head eye
        if (i === 0) {
          ctx.fillStyle = "#fff";
          const eyeSize = 3;
          ctx.fillRect(s.x*SIZE + 4, s.y*SIZE + 4, eyeSize, eyeSize);
          ctx.fillRect(s.x*SIZE + SIZE-7, s.y*SIZE + 4, eyeSize, eyeSize);
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || "#32cd32";
        }
      });

      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 24px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvas.width/2, canvas.height/2 - 10);
        ctx.font = "16px sans-serif";
        ctx.fillText("Press Start to play again", canvas.width/2, canvas.height/2 + 16);
      }
    }

    function endGame() {
      gameOver = true;
      clearInterval(timer);
      saveHighScore(score);
      draw();
    }

    function updateScore() {
      scoreEl.textContent = score;
    }

    // controls
    window.addEventListener("keydown", e => {
      const k = e.key.toLowerCase();
      if (["arrowup","w"].includes(k)) nextDir = {x:0, y:-1};
      else if (["arrowdown","s"].includes(k)) nextDir = {x:0, y:1};
      else if (["arrowleft","a"].includes(k)) nextDir = {x:-1, y:0};
      else if (["arrowright","d"].includes(k)) nextDir = {x:1, y:0};
      else if (k === " ") togglePause();
    });

    // mobile pad
    document.getElementById("pad").addEventListener("click", (e) => {
      const d = e.target.getAttribute("data-dir");
      if (!d) return;
      if (d === "up")    nextDir = {x:0, y:-1};
      if (d === "down")  nextDir = {x:0, y:1};
      if (d === "left")  nextDir = {x:-1, y:0};
      if (d === "right") nextDir = {x:1, y:0};
    });

    btnStart.addEventListener("click", init);
    btnPause.addEventListener("click", togglePause);

    function togglePause() {
      if (gameOver) return;
      paused = !paused;
      if (!paused) {
        clearInterval(timer);
        timer = setInterval(tick, SPEED_MS);
      }
    }

    async function fetchHighScore() {
      try {
        const res = await fetch("/highscore");
        const data = await res.json();
        highEl.textContent = data.score || 0;
      } catch {}
    }

    async function saveHighScore(s) {
      try {
        const res = await fetch("/highscore", {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({score: s})
        });
        const data = await res.json();
        highEl.textContent = data.score || 0;
      } catch {}
    }

    // initial
    fetchHighScore();
    draw(); // draw empty board before start
  </script>
</body>
</html>
